import os
import json
import urllib.request # Added for Hack Club API calls
from flask import Flask, render_template, redirect, url_for, flash, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from werkzeug.security import generate_password_hash, check_password_hash

# --- Hack Club AI Configuration ---
HACKCLUB_API_URL = "https://ai.hackclub.com/chat/completions"
# Placeholder for context that the LLM can use, set to IGCSE context
IGCSE_INFO_TEXT = "The user is studying IGCSE level content in Math, Physics, Biology, and Chemistry. Focus your answers on curriculum topics."
# --- End AI Configuration ---


app = Flask(__name__)
# IMPORTANT: Use a secure, complex key in a real application.
app.config['SECRET_KEY'] = 'SNSnT_LoJM8ejQ1GFtSJCdcrQJCg1NInP5Klbp68Rqs'
# Using sqlite for persistence
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///igcse_study.sqlite3'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'

# --- Database Models ---

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(250), nullable=False) # Increased size for hashed passwords
    flashcards = db.relationship('Flashcard', backref='owner', lazy=True)

class Folder(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('folder.id'), nullable=True)
    
    parent = db.relationship('Folder', remote_side=[id], backref='subfolders')
    flashcards = db.relationship('Flashcard', backref='folder', lazy='dynamic')

class Flashcard(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    topic = db.Column(db.String(100), nullable=False)
    question = db.Column(db.Text, nullable=False)
    answer = db.Column(db.Text, nullable=False)
    folder_id = db.Column(db.Integer, db.ForeignKey('folder.id'), nullable=True)

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

# --- API for Frontend Persistence ---

@app.route('/save_flashcards', methods=['POST'])
@login_required
def save_flashcards():
    """
    Saves flashcards generated by the frontend LLM call (or manually created) 
    to the database for the current logged-in user.
    """
    try:
        data = request.get_json()
        flashcards_data = data.get('flashcards', [])
        folder_id = data.get('folder_id', None) # Get the target folder_id

        if not flashcards_data:
            return jsonify({'message': 'No flashcards provided to save.'}), 200

        new_flashcards = []
        for fc in flashcards_data:
            # Assuming the flashcards sent from the frontend have 'topic', 'question', and 'answer'
            new_flashcard = Flashcard(
                user_id=current_user.id,
                topic=fc.get('topic', 'Unassigned'),
                question=fc.get('question'),
                answer=fc.get('answer'),
                folder_id=folder_id # Assign the flashcard to the folder
            )
            new_flashcards.append(new_flashcard)

        db.session.bulk_save_objects(new_flashcards)
        db.session.commit()
        return jsonify({'message': f'{len(new_flashcards)} flashcards saved successfully!'})

    except Exception as e:
        db.session.rollback()
        print(f"Error saving flashcards: {e}")
        return jsonify({'error': 'Failed to save flashcards due to a server error.'}), 500

@app.route('/generate_flashcards_ai', methods=['POST'])
@login_required
def generate_flashcards_ai():
    """
    Uses an AI to generate flashcards from a given topic/text and saves them.
    """
    data = request.json
    text = data.get('text', '').strip()
    topic = data.get('topic', 'Generated').strip()

    if not text:
        return jsonify({'error': 'Please provide a topic or text to generate flashcards from.'}), 400

    try:
        # A very specific prompt to get structured JSON from the AI
        system_prompt = (
            "You are an expert flashcard creation assistant. Based on the user's text, generate 5-7 concise, high-quality flashcards. "
            "Each flashcard must have a 'question' and an 'answer' field. "
            "Respond ONLY with a valid JSON array of objects. Do not include any other text, explanation, or markdown. "
            "Example: [{\"question\": \"What is the powerhouse of the cell?\", \"answer\": \"The mitochondria.\"}]"
        )
        
        api_messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": text}
        ]

        req = urllib.request.Request(
            HACKCLUB_API_URL,
            data=json.dumps({"model": "gpt-4o-mini", "messages": api_messages, "max_tokens": 1000}).encode('utf-8'),
            headers={'Content-Type': 'application/json'}
        )

        with urllib.request.urlopen(req) as response:
            if response.status == 200:
                response_text = response.read().decode('utf-8')
                ai_response_data = json.loads(response_text)
                content = ai_response_data['choices'][0]['message']['content']
                
                # Clean the response to ensure it's valid JSON
                json_start = content.find('[')
                json_end = content.rfind(']') + 1
                flashcards_json_str = content[json_start:json_end]
                
                flashcards_data = json.loads(flashcards_json_str)
                return jsonify({'flashcards': flashcards_data})
            else:
                return jsonify({'error': 'Failed to get a response from the AI.'}), 500
    except Exception as e:
        print(f"AI Flashcard Generation Error: {e}")
        return jsonify({'error': 'An error occurred while generating flashcards.'}), 500

@app.route('/create_folder', methods=['POST'])
@login_required
def create_folder():
    """Creates a new folder for the current user."""
    data = request.json
    name = data.get('name', '').strip()
    parent_id = data.get('parent_id')

    if not name:
        return jsonify({'error': 'Folder name cannot be empty.'}), 400

    try:
        new_folder = Folder(name=name, user_id=current_user.id, parent_id=parent_id)
        db.session.add(new_folder)
        db.session.commit()
        return jsonify({'id': new_folder.id, 'name': new_folder.name, 'parent_id': new_folder.parent_id})
    except Exception as e:
        db.session.rollback()
        print(f"Folder Creation Error: {e}")
        return jsonify({'error': 'Failed to create folder.'}), 500

# --- Hack Club AI Chat Endpoint ---

@app.route("/chat", methods=["POST"])
@login_required # Protect the API endpoint
def chat():
    data = request.json
    # Expect a list of messages for context
    messages = data.get("messages", [])

    if not messages:
        return jsonify({"reply": "⚠️ No message provided."})

    # The user's new message is the last one in the list
    user_message = messages[-1].get("content", "").strip()

    try:
        # System Instruction for the IGCSE TutorBot
        system_content = (
            "You are IGCSE TutorBot, an extremely helpful and strict assistant for students studying IGCSE "
            "level content. Your responses must be concise, straightforward, and delivered as the final answer only. "
            "Do not include any reasoning, thoughts, or conversational filler. "
            "Your responses should be in Markdown format."
        )

        # Prepend the system message to the conversation history
        api_messages = [{"role": "system", "content": system_content}] + messages
        
        req = urllib.request.Request(
            HACKCLUB_API_URL,
            data=json.dumps({
                "model": "gpt-4o-mini",
                # Pass the entire conversation history to the AI
                "messages": api_messages,
                "max_tokens": 800
            }).encode('utf-8'),
            headers={'Content-Type': 'application/json'}
        )
        with urllib.request.urlopen(req) as response:
            if response.status == 200:
                response_data = json.loads(response.read().decode('utf-8'))
                # Extract the reply from the Hack Club API response structure
                content = response_data['choices'][0]['message']['content']

                # Strip out the <think>...</think> block from the response
                think_end_tag = '</think>'
                think_end_index = content.find(think_end_tag)
                if think_end_index != -1:
                    # If the tag is found, take the content after it
                    reply = content[think_end_index + len(think_end_tag):].strip()
                else:
                    reply = content.strip()

                return jsonify({"reply": reply})
            else:
                # Read error response body if available
                error_body = response.read().decode('utf-8', errors='ignore')
                print(f"Hack Club API Error Status {response.status}: {error_body}")
                return jsonify({"reply": "⚠️ Error connecting to Hack Club AI API."})

    except urllib.error.HTTPError as e:
        # Catch specific HTTP errors
        print(f"HTTP Error: {e.code}, {e.read().decode('utf-8', errors='ignore')}")
        return jsonify({"reply": "⚠️ Error connecting to Hack Club AI API due to an HTTP error."})
    except Exception as e:
        print("General Error:", e)
        return jsonify({"reply": "⚠️ An unexpected error occurred while processing the request."})

# --- Authentication Routes ---

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('profile'))
    if request.method == 'POST':
        user = User.query.filter_by(username=request.form['username']).first()
        if user and check_password_hash(user.password, request.form['password']):
            login_user(user, remember=True)
            return redirect(url_for('profile'))
        flash('Invalid username or password', 'error')
    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('profile'))
    if request.method == 'POST':
        try:
            hashed_password = generate_password_hash(request.form['password'], method='pbkdf2:sha256')
            new_user = User(username=request.form['username'], email=request.form['email'], password=hashed_password)
            db.session.add(new_user)
            db.session.commit()
            flash('Account created successfully! You are now logged in.', 'success')
            login_user(new_user)
            return redirect(url_for('profile'))
        except Exception as e:
            db.session.rollback()
            flash('Registration failed. Username or Email might already be taken.', 'error')
            print(f"Registration Error: {e}")
            return redirect(url_for('register'))
    return render_template('register.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'info')
    return redirect(url_for('index'))

# --- Application Routes ---

@app.route('/')
def index():
    if current_user.is_authenticated:
        return redirect(url_for('profile'))
    return render_template('index.html')

@app.route('/profile')
@login_required
def profile():
    # Query user's flashcards to generate stats
    user_flashcards = Flashcard.query.filter_by(user_id=current_user.id).all()
    
    # Calculate stats
    total_flashcards = len(user_flashcards)
    topics_dict = {}
    for fc in user_flashcards:
        topics_dict[fc.topic] = topics_dict.get(fc.topic, 0) + 1
    
    # Get the 5 most recent flashcards
    recent_flashcards = Flashcard.query.filter_by(user_id=current_user.id).order_by(Flashcard.id.desc()).limit(5).all()
    return render_template('profile.html', total_flashcards=total_flashcards, topics_data=topics_dict, recent_flashcards=recent_flashcards)

@app.route('/chatbot')
@login_required
def chatbot():
    return render_template('chatbot.html')

@app.route('/flashcards')
@login_required
def flashcards():
    # Fetch top-level folders and flashcards (not in any folder)
    top_level_folders = Folder.query.filter_by(user_id=current_user.id, parent_id=None).all()
    top_level_flashcards = Flashcard.query.filter_by(user_id=current_user.id, folder_id=None).all()

    def build_folder_tree(folder):
        """Recursively build a dictionary representing the folder and its contents."""
        return {
            'id': folder.id,
            'name': folder.name,
            'subfolders': [build_folder_tree(sub) for sub in folder.subfolders],
            'flashcards': [{'id': fc.id, 'question': fc.question, 'answer': fc.answer, 'topic': fc.topic} for fc in folder.flashcards]
        }

    folder_structure = [build_folder_tree(f) for f in top_level_folders]
    
    return render_template('flashcards.html', folder_structure=folder_structure, root_flashcards=top_level_flashcards)


if __name__ == '__main__':
    with app.app_context():
        # Creates tables and adds initial data if not present
        db.create_all()
    app.run(debug=True, port=5001)
