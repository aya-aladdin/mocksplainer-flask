{% extends 'base.html' %}

{% block title %}Flashcards System{% endblock %}
{% block head %}<link rel="stylesheet" href="{{ url_for('static', filename='flashcards.css') }}">{% endblock %}

{% block content %}
<div class="flashcards-layout">
    <!-- Sidebar for Folders -->
    <aside class="flashcards-sidebar">
        <div class="sidebar-header">
            <h3>My Collection</h3>
            <button class="btn btn-ghost btn-sm" id="new-folder-btn">+ New Folder</button>
        </div>
        <div id="folder-tree">
            <!-- Folder structure will be rendered here by JavaScript -->
        </div>
    </aside>

    <!-- Main Content Area -->
    <main class="flashcards-main">
        <div class="flashcards-main-header">
            <div class="header-title-container">
                <h1 id="current-folder-name">All Flashcards</h1>
            </div>
            <div class="actions">
                <button class="btn btn-secondary" id="cancel-selection-btn" style="display: none;">Cancel Selection</button>
                <button class="btn btn-secondary" id="new-flashcard-btn">Create Flashcard</button>
                <button class="btn btn-primary" id="learn-mode-btn">Learn</button>
            </div>
        </div>

        <!-- Breadcrumbs -->
        <nav id="breadcrumbs" aria-label="breadcrumb"></nav>

        <!-- Items (Folders and Flashcards) -->
        <div id="items-container" class="items-grid">
            <!-- Items will be rendered here by JavaScript -->
        </div>
    </main>
</div>

<!-- Select Folders for Learn Mode Modal -->
<div id="select-learn-folders-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h3>Select folders to learn</h3>
        <div id="select-learn-folders-tree" style="max-height: 300px; overflow-y: auto; margin: 1rem 0;">
            <!-- Folder tree with checkboxes will be rendered here -->
        </div>
        <div class="modal-actions">
            <button class="btn btn-secondary" id="cancel-learn-selection-btn">Cancel</button>
            <button class="btn btn-primary" id="start-learn-session-btn">Start Learning</button>
        </div>
    </div>
</div>

<!-- Learn Mode Modal -->
<div id="learn-mode-modal" class="modal-overlay" style="display: none;">
    <div class="learn-modal-content">
        <button class="modal-close-btn" id="close-learn-modal">&times;</button>
        <div class="learn-flashcard" onclick="this.parentElement.classList.toggle('flipped')">
            <div class="learn-flashcard-inner">
                <div class="learn-flashcard-front">
                    <p id="learn-question"></p>
                </div>
                <div class="learn-flashcard-back">
                    <p id="learn-answer"></p>
                </div>
            </div>
        </div>
        <div id="learn-controls">
            <div id="learn-progress">1 / 10</div>
            <div id="learn-feedback-btns" style="display: none;">
                <button id="learn-wrong-btn" class="btn btn-danger">I was wrong</button>
                <button id="learn-right-btn" class="btn btn-success">I was right</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Flashcard Modal -->
<div id="create-flashcard-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content creator-modal-content">
        <button class="modal-close-btn" id="close-create-modal">&times;</button>
        <div class="creator-tabs">
            <button class="tab-link active" data-tab="generate-ai">Generate with AI</button>
            <button class="tab-link" data-tab="create-manual">Create Manually</button>
        </div>

        <!-- AI Generator Tab -->
        <div id="generate-ai" class="tab-content" style="display: block;">
            <form id="ai-generator-form">
                <p class="muted" style="font-size: 0.9rem; margin-bottom: 1rem;">Enter a topic or paste your notes, and the AI will generate flashcards for you.</p>
                <div class="form-group">
                    <label for="ai-topic">Topic</label>
                    <input type="text" id="ai-topic" class="form-control" placeholder="e.g., The Krebs Cycle" required>
                </div>
                <div class="form-group">
                    <label for="ai-notes">Notes (Optional)</label>
                    <textarea id="ai-notes" class="form-control" rows="4" placeholder="Paste your notes here... The AI will use this as context."></textarea>
                </div>
                <button type="submit" class="btn btn-primary">Generate Flashcards</button>
                <div id="ai-loading-spinner" style="display: none; margin-top: 1rem;">Generating...</div>
            </form>
        </div>

        <!-- Manual Creator Tab -->
        <div id="create-manual" class="tab-content" style="display: none;">
            <form id="manual-creator-form">
                <div class="form-group">
                    <label for="manual-question">Question</label>
                    <textarea id="manual-question" class="form-control" rows="2" required></textarea>
                </div>
                <div class="form-group">
                    <label for="manual-answer">Answer</label>
                    <textarea id="manual-answer" class="form-control" rows="2" required></textarea>
                </div>
                <button type="submit" class="btn btn-primary">Save Flashcard</button>
            </form>
        </div>
    </div>
</div>

<!-- Emoji Picker Modal -->
<div id="emoji-picker-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content emoji-picker-content">
        <h3>Select an Icon</h3>
        <div id="emoji-grid">
            <!-- Emojis will be populated here by JS -->
        </div>
    </div>
</div>

<!-- Move Item Modal (Structure Only) -->
<div id="move-item-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h3>Move Item to...</h3>
        <div id="move-folder-tree">
            <!-- Simplified folder tree for selection -->
        </div>
        <div class="modal-actions">
            <button class="btn btn-secondary" id="cancel-move-btn">Cancel</button>
            <button class="btn btn-primary" id="confirm-move-btn">Move</button>
        </div>
    </div>
</div>

<!-- Bulk Action Bar -->
<div id="bulk-action-bar" class="bulk-action-bar">
    <span id="selection-count" class="selection-count">0 items selected</span>
    <div class="actions">
        <button class="btn btn-secondary btn-sm" id="bulk-move-btn">Move</button>
        <button class="btn btn-secondary btn-sm" id="bulk-delete-btn">Delete</button>
    </div>
</div>


{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- STATE ---
    const fullData = {
        folders: {{ folder_structure | tojson | safe }},
        root_flashcards: {{ root_flashcards | tojson | safe }}
    };
    let itemToMove = null;
    let itemToChangeIcon = null;
    let currentFolderId = null;
    let selectedItems = new Set();
    let breadcrumbs = [];

    // --- DOM ELEMENTS ---
    const folderTreeEl = document.getElementById('folder-tree');
    const itemsContainerEl = document.getElementById('items-container');
    const currentFolderNameEl = document.getElementById('current-folder-name');
    const breadcrumbsEl = document.getElementById('breadcrumbs');
    const newFolderBtn = document.getElementById('new-folder-btn');
    const moveItemModal = document.getElementById('move-item-modal');
    const newFlashcardBtn = document.getElementById('new-flashcard-btn');
    const createFlashcardModal = document.getElementById('create-flashcard-modal');
    const moveFolderTreeEl = document.getElementById('move-folder-tree');
    const confirmMoveBtn = document.getElementById('confirm-move-btn');
    const cancelMoveBtn = document.getElementById('cancel-move-btn');
    const bulkActionBar = document.getElementById('bulk-action-bar');
    const selectionCountEl = document.getElementById('selection-count');
    const bulkMoveBtn = document.getElementById('bulk-move-btn');
    const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
    const cancelSelectionBtn = document.getElementById('cancel-selection-btn');
    const learnModeBtn = document.getElementById('learn-mode-btn');
    const selectLearnFoldersModal = document.getElementById('select-learn-folders-modal');
    const startLearnSessionBtn = document.getElementById('start-learn-session-btn');
    const cancelLearnSelectionBtn = document.getElementById('cancel-learn-selection-btn');
    const learnModeModal = document.getElementById('learn-mode-modal');
    const closeLearnModalBtn = document.getElementById('close-learn-modal');


    // --- RENDER FUNCTIONS ---

    function renderFolderTree(folders, parentElement, level = 0) {
        const ul = document.createElement('ul');
        ul.style.paddingLeft = level > 0 ? '20px' : '0';
        ul.style.listStyle = 'none';

        folders.forEach(folder => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.id = `folder-link-${folder.id}`;
            a.href = '#';
            a.dataset.folderId = folder.id;
            a.innerHTML = `<span class="folder-icon">${folder.icon}</span> ${folder.name}`;
            a.addEventListener('click', (e) => {
                e.preventDefault();
                navigateToFolder(folder.id);
            });
            li.appendChild(a);

            if (folder.subfolders && folder.subfolders.length > 0) {
                renderFolderTree(folder.subfolders, li, level + 1);
            }
            ul.appendChild(li);
        });
        parentElement.appendChild(ul);
    }
    
    function renderMoveFolderTree(folders, parentElement, level = 0) {
        const ul = document.createElement('ul');
        if (level > 0) {
            ul.classList.add('nested');
        }

        folders.forEach(folder => {
            // Prevent moving a folder into itself
            if (itemToMove && itemToMove.type === 'folder' && itemToMove.id === folder.id) {
                return;
            }

            const li = document.createElement('li');
            const hasSubfolders = folder.subfolders && folder.subfolders.length > 0;

            const itemDiv = document.createElement('div');
            itemDiv.className = 'move-folder-item';

            // Add toggle arrow if there are subfolders
            if (hasSubfolders) {
                const toggleArrow = document.createElement('span');
                toggleArrow.className = 'toggle-arrow';
                toggleArrow.innerHTML = 'â–¶';
                toggleArrow.onclick = (e) => {
                    e.stopPropagation();
                    const sublist = li.querySelector('ul');
                    if (sublist) {
                        sublist.classList.toggle('open');
                        toggleArrow.classList.toggle('open');
                    }
                };
                itemDiv.appendChild(toggleArrow);
            }

            const a = document.createElement('a');
            a.href = '#';
            a.dataset.folderId = folder.id;
            a.innerHTML = `<span class="folder-icon">${folder.icon}</span> ${folder.name}`;
            a.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#move-folder-tree a').forEach(link => link.classList.remove('active'));
                a.classList.add('active');
            });
            itemDiv.appendChild(a);
            li.appendChild(itemDiv);

            if (hasSubfolders) {
                renderMoveFolderTree(folder.subfolders, li, level + 1);
            }

            ul.appendChild(li);
        });
        parentElement.appendChild(ul);
    }

    function renderLearnFolderTree(folders, parentElement) {
        const ul = document.createElement('ul');
        folders.forEach(folder => {
            const li = document.createElement('li');
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = folder.id;
            checkbox.id = `learn-check-${folder.id}`;
            
            label.setAttribute('for', checkbox.id);
            label.innerHTML = `<span class="folder-icon">${folder.icon}</span> ${folder.name}`;
            
            li.appendChild(checkbox);
            li.appendChild(label);

            if (folder.subfolders && folder.subfolders.length > 0) {
                const subUl = document.createElement('ul');
                renderLearnFolderTree(folder.subfolders, subUl);
                li.appendChild(subUl);
            }
            ul.appendChild(li);
        });
        parentElement.appendChild(ul);
    }




    function renderItems(items) {
        itemsContainerEl.innerHTML = ''; // Clear current items
        
        // Render subfolders
        (items.folders || []).forEach(folder => {
            const folderEl = document.createElement('div');
            folderEl.className = 'item-card folder-item';
            folderEl.dataset.itemId = folder.id;
            folderEl.dataset.itemType = 'folder';
            const uniqueId = `folder-${folder.id}`;
            const isSelected = selectedItems.has(uniqueId);

            folderEl.innerHTML = `
                <div class="item-icon">${folder.icon}</div>
                <div class="item-name">${folder.name}</div>
                <div class="item-menu-btn">...</div>
                <div class="item-menu-dropdown">
                    <a href="#" class="select-toggle-btn">${isSelected ? 'Deselect' : 'Select'}</a>
                    <a href="#" class="rename-btn">Rename</a>
                    <a href="#" class="change-icon-btn">Change Icon</a>
                    <a href="#" class="move-btn">Move...</a>
                    <a href="#" class="delete-btn">Delete</a>
                </div>
            `;
            if (isSelected) folderEl.classList.add('selected');

            folderEl.addEventListener('click', (e) => {
                // Only navigate if the click was not on the menu button or inside the dropdown
                if (selectedItems.size > 0) {
                    if (!e.target.closest('.item-menu-btn') && !e.target.closest('.item-menu-dropdown')) {
                        toggleSelection(folderEl);
                    }
                } else if (!e.target.closest('.item-menu-btn') && !e.target.closest('.item-menu-dropdown')) {
                    navigateToFolder(folder.id);
                }
            });
            itemsContainerEl.appendChild(folderEl);
        });

        // Render flashcards
        (items.flashcards || []).forEach(flashcard => {
            const flashcardEl = document.createElement('div');
            flashcardEl.className = 'item-card flashcard-item'; // Keep this class for grid styling
            flashcardEl.dataset.itemId = flashcard.id;
            flashcardEl.dataset.itemType = 'flashcard';
            const uniqueId = `flashcard-${flashcard.id}`;
            const isSelected = selectedItems.has(uniqueId);

            flashcardEl.innerHTML = `
                <div class="flashcard-inner">
                    <div class="item-content flashcard-front">
                        <div class="item-name">${flashcard.question}</div>
                    </div>
                    <div class="item-content flashcard-back">
                        <p>${flashcard.answer}</p>
                    </div>
                </div>
                <div class="flashcard-footer">
                    <div class="item-menu-btn">...</div>
                    <div class="item-menu-dropdown">
                        <a href="#" class="select-toggle-btn">${isSelected ? 'Deselect' : 'Select'}</a>
                        <a href="#" class="rename-btn">Rename</a>
                        <a href="#" class="delete-btn">Delete</a>
                    </div>
                </div>
            `;
            if (isSelected) flashcardEl.classList.add('selected');

            flashcardEl.addEventListener('click', (e) => {
                if (selectedItems.size > 0) {
                    // If in selection mode, clicking the card toggles selection
                    if (!e.target.closest('.item-menu-btn') && !e.target.closest('.item-menu-dropdown')) {
                        toggleSelection(flashcardEl);
                    }
                } else if (!e.target.closest('.item-menu-btn') && !e.target.closest('.item-menu-dropdown')) {
                    flashcardEl.classList.toggle('flipped');
                }
            });

            itemsContainerEl.appendChild(flashcardEl);
        });
        updateBulkActionBar();
    }

    function updateBulkActionBar() {
        const count = selectedItems.size;
        if (count > 0) {
            selectionCountEl.textContent = `${count} item${count > 1 ? 's' : ''} selected`;
            bulkActionBar.classList.add('visible');
            cancelSelectionBtn.style.display = 'inline-block';
        } else {
            bulkActionBar.classList.remove('visible');
            cancelSelectionBtn.style.display = 'none';
        }
    }

    function renderBreadcrumbs() {
        breadcrumbsEl.innerHTML = '';
        const homeLink = document.createElement('a');
        homeLink.href = '#';
        homeLink.innerText = 'All Flashcards';
        homeLink.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToFolder(null);
        });
        breadcrumbsEl.appendChild(homeLink);

        breadcrumbs.forEach((crumb, index) => {
            breadcrumbsEl.innerHTML += ' / ';
            const crumbLink = document.createElement('a');
            crumbLink.href = '#';
            crumbLink.innerText = crumb.name;
            if (index < breadcrumbs.length - 1) {
                crumbLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    navigateToFolder(crumb.id);
                });
            }
            breadcrumbsEl.appendChild(crumbLink);
        });
    }

    // --- DATA & NAVIGATION LOGIC ---

    function findFolder(folderId, folders = fullData.folders) {
        for (const folder of folders) {
            if (folder.id === folderId) return folder;
            const found = findFolder(folderId, folder.subfolders);
            if (found) return found;
        }
        return null;
    }

    function buildBreadcrumbs(folderId, folders = fullData.folders, path = []) {
        for (const folder of folders) {
            const currentPath = [...path, { id: folder.id, name: folder.name }];
            if (folder.id === folderId) {
                return currentPath;
            }
            const foundPath = buildBreadcrumbs(folderId, folder.subfolders, currentPath);
            if (foundPath) return foundPath;
        }
        return null;
    }

    function navigateToFolder(folderId) {
        currentFolderId = folderId;
        if (folderId === null) {
            // Root view
            currentFolderNameEl.innerText = 'All Flashcards';
            breadcrumbs = [];
            renderItems({ folders: fullData.folders, flashcards: fullData.root_flashcards });
        } else {
            const folder = findFolder(folderId);
            if (folder) {
                currentFolderNameEl.innerText = folder.name;
                breadcrumbs = buildBreadcrumbs(folderId);
                // Clear selection when navigating into a new folder
                selectedItems.clear();
                renderItems({ folders: folder.subfolders, flashcards: folder.flashcards });
            }
        }
        renderBreadcrumbs();

        // Update active class in sidebar
        document.querySelectorAll('#folder-tree a').forEach(a => a.classList.remove('active'));
        if (folderId) {
            const activeLink = document.getElementById(`folder-link-${folderId}`);
            if (activeLink) activeLink.classList.add('active');
        }
    }

    // --- EVENT HANDLERS ---

    newFolderBtn.addEventListener('click', async () => {
        const name = prompt('Enter new folder name:');
        if (name && name.trim()) {
            try {
                const response = await fetch('{{ url_for("create_folder") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name.trim(), parent_id: currentFolderId })
                });
                if (!response.ok) throw new Error('Failed to create folder.');
                
                const newFolder = await response.json();
                
                // Add to local data structure and re-render
                const newFolderData = { ...newFolder, subfolders: [], flashcards: [] };
                if (currentFolderId === null) {
                    fullData.folders.push(newFolderData);
                } else {
                    const parent = findFolder(currentFolderId);
                    parent.subfolders.push(newFolderData);
                }
                
                // Re-render everything
                folderTreeEl.innerHTML = '';
                renderFolderTree(fullData.folders, folderTreeEl);
                navigateToFolder(currentFolderId);

            } catch (error) {
                console.error(error);
                alert('Error creating folder.');
            }
        }
    });

    learnModeBtn.addEventListener('click', () => {
        const treeContainer = document.getElementById('select-learn-folders-tree');
        treeContainer.innerHTML = '';
        renderLearnFolderTree(fullData.folders, treeContainer);
        selectLearnFoldersModal.style.display = 'flex';
    });

    newFlashcardBtn.addEventListener('click', () => {
        createFlashcardModal.style.display = 'flex';
    });

    document.getElementById('close-create-modal').addEventListener('click', () => {
        createFlashcardModal.style.display = 'none';
    });

    // Event delegation for item menus
    itemsContainerEl.addEventListener('click', function(e) {
        const target = e.target;

        // Prevent card navigation when clicking menu button
        if (target.classList.contains('item-menu-btn')) {
            e.stopPropagation();
            // Close other menus
            document.querySelectorAll('.item-card.menu-open').forEach(card => {
                if (card !== target.closest('.item-card')) {
                    card.classList.remove('menu-open');
                    card.querySelector('.item-menu-dropdown').classList.remove('visible');
                }
            });
            target.closest('.item-card').classList.toggle('menu-open');
            target.nextElementSibling.classList.toggle('visible');
        }

        // Handle select/deselect from menu
        if (target.classList.contains('select-toggle-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            toggleSelection(card);
        }

        // Handle rename action
        if (target.classList.contains('rename-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            const itemId = card.dataset.itemId;
            const itemType = card.dataset.itemType;
            const currentName = card.querySelector('.item-name').innerText;
            const newName = prompt(`Enter new name for "${currentName}":`, currentName);

            if (newName && newName.trim() !== currentName) {
                fetch('{{ url_for("update_item") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_id: itemId, item_type: itemType, name: newName.trim() })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        // For simplicity, we reload the page to see changes.
                        // A more advanced implementation would update the state locally.
                        window.location.reload();
                    }
                });
            }
        }

        // Handle move action
        if (target.classList.contains('move-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            itemToMove = {
                id: card.dataset.itemId,
                type: card.dataset.itemType
            };
            openMoveModal();
        }

        // Handle change icon action
        if (target.classList.contains('change-icon-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            itemToChangeIcon = {
                id: card.dataset.itemId
            };
            openEmojiPicker();
        }

        // Handle delete action
        if (target.classList.contains('delete-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            const itemId = card.dataset.itemId;
            const itemType = card.dataset.itemType;
            const itemName = card.querySelector('.item-name').innerText;

            if (confirm(`Are you sure you want to delete "${itemName}"?`)) {
                fetch('{{ url_for("delete_item") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_id: itemId, item_type: itemType })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        card.remove(); // Remove from DOM instantly
                    } else {
                        alert(data.error || 'Failed to delete item.');
                    }
                });
            }
        }
    });

    function toggleSelection(cardElement) {
        const uniqueId = `${cardElement.dataset.itemType}-${cardElement.dataset.itemId}`;
        const menuLink = cardElement.querySelector('.select-toggle-btn');

        if (selectedItems.has(uniqueId)) {
            selectedItems.delete(uniqueId);
            cardElement.classList.remove('selected');
            if (menuLink) menuLink.textContent = 'Select';
        } else {
            selectedItems.add(uniqueId);
            cardElement.classList.add('selected');
            if (menuLink) menuLink.textContent = 'Deselect';
        }
        updateBulkActionBar();
    }

    // --- BULK ACTION LOGIC ---

    cancelSelectionBtn.addEventListener('click', () => {
        selectedItems.clear();
        document.querySelectorAll('.item-card.selected').forEach(card => card.classList.remove('selected'));
        document.querySelectorAll('.select-toggle-btn').forEach(btn => btn.textContent = 'Select');
        updateBulkActionBar();
    });

    bulkDeleteBtn.addEventListener('click', async () => {
        if (selectedItems.size === 0) return;
        if (confirm(`Are you sure you want to delete ${selectedItems.size} item(s)?`)) {
            const itemsToDelete = Array.from(selectedItems).map(uid => {
                const [type, id] = uid.split('-');
                return { id: parseInt(id), type };
            });

            try {
                const response = await fetch('{{ url_for("delete_items_bulk") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ items: itemsToDelete })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to delete items.');
                
                // On success, remove from DOM and clear selection
                itemsToDelete.forEach(item => {
                    const card = itemsContainerEl.querySelector(`[data-item-id='${item.id}'][data-item-type='${item.type}']`);
                    if (card) card.remove();
                });
                selectedItems.clear();
                updateBulkActionBar();

            } catch (error) {
                console.error(error);
                alert(`Error deleting items: ${error.message}`);
            }
        }
    });

    bulkMoveBtn.addEventListener('click', () => {
        if (selectedItems.size > 0) openMoveModal();
    });

    // --- MODAL LOGIC ---

    function openMoveModal() {
        moveFolderTreeEl.innerHTML = '';
        // Add a "Root" option
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.dataset.folderId = 'null'; // Use string 'null' for root
        rootLink.innerHTML = `ðŸ  All Flashcards (Root)`;
        rootLink.addEventListener('click', (e) => {
            e.preventDefault();
            document.querySelectorAll('#move-folder-tree a').forEach(link => link.classList.remove('active'));
            rootLink.classList.add('active');
        });
        moveFolderTreeEl.appendChild(rootLink);

        renderMoveFolderTree(fullData.folders, moveFolderTreeEl);
        moveItemModal.style.display = 'flex';
    }

    confirmMoveBtn.addEventListener('click', async () => {
        const selectedLink = moveFolderTreeEl.querySelector('a.active');
        if (!selectedLink) return;

        const targetFolderId = selectedLink.dataset.folderId === 'null' ? null : parseInt(selectedLink.dataset.folderId);
        const isBulkMove = selectedItems.size > 0 && !itemToMove;
        const endpoint = isBulkMove ? '{{ url_for("move_items_bulk") }}' : '{{ url_for("move_item") }}';

        let payload;
        if (isBulkMove) {
            const items = Array.from(selectedItems).map(uid => ({ type: uid.split('-')[0], id: uid.split('-')[1] }));
            payload = { items: items, target_folder_id: targetFolderId };
        } else {
            payload = { item_id: itemToMove.id, item_type: itemToMove.type, target_folder_id: targetFolderId };
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error('Failed to move item.');
            
            window.location.reload(); // Reload to see changes
        } catch (error) {
            console.error(error);
            alert('Error moving item.');
        }
    });

    cancelMoveBtn.addEventListener('click', () => {
        moveItemModal.style.display = 'none';
        itemToMove = null; // Clear single item move state
    });

    moveItemModal.addEventListener('click', (e) => {
        if (e.target === moveItemModal) {
            moveItemModal.style.display = 'none';
        }
    });

    // --- Learn Mode Logic ---
    let learnSession = {
        flashcards: [],
        currentIndex: 0,
        correct: 0,
        incorrect: 0
    };

    cancelLearnSelectionBtn.addEventListener('click', () => {
        selectLearnFoldersModal.style.display = 'none';
    });

    closeLearnModalBtn.addEventListener('click', () => {
        learnModeModal.style.display = 'none';
    });

    startLearnSessionBtn.addEventListener('click', async () => {
        const selectedCheckboxes = document.querySelectorAll('#select-learn-folders-tree input[type="checkbox"]:checked');
        const folderIds = Array.from(selectedCheckboxes).map(cb => cb.value);

        if (folderIds.length === 0) {
            alert('Please select at least one folder to learn.');
            return;
        }

        try {
            const response = await fetch('{{ url_for("get_learn_session_flashcards") }}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ folder_ids: folderIds })
            });
            const data = await response.json();

            if (data.flashcards && data.flashcards.length > 0) {
                // Shuffle the flashcards for a random order
                learnSession.flashcards = data.flashcards.sort(() => Math.random() - 0.5);
                learnSession.currentIndex = 0;
                learnSession.correct = 0;
                learnSession.incorrect = 0;
                
                selectLearnFoldersModal.style.display = 'none';
                learnModeModal.style.display = 'flex';
                displayCurrentLearnCard();
            } else {
                alert('The selected folders do not contain any flashcards.');
            }
        } catch (error) {
            console.error('Error starting learn session:', error);
            alert('Could not start the learning session.');
        }
    });

    function displayCurrentLearnCard() {
        if (learnSession.currentIndex >= learnSession.flashcards.length) {
            // Session finished
            alert(`Session Complete!\n\nCorrect: ${learnSession.correct}\nIncorrect: ${learnSession.incorrect}`);
            learnModeModal.style.display = 'none';
            return;
        }

        const card = learnSession.flashcards[learnSession.currentIndex];
        document.getElementById('learn-question').textContent = card.question;
        document.getElementById('learn-answer').textContent = card.answer;
        document.getElementById('learn-progress').textContent = `${learnSession.currentIndex + 1} / ${learnSession.flashcards.length}`;
        
        // Reset card state
        learnModeModal.querySelector('.learn-modal-content').classList.remove('flipped');
        document.getElementById('learn-feedback-btns').style.display = 'none';

        // Show feedback buttons after a delay to encourage flipping
        setTimeout(() => {
            if (learnModeModal.querySelector('.learn-modal-content').classList.contains('flipped')) {
                document.getElementById('learn-feedback-btns').style.display = 'flex';
            }
        }, 1000);

        learnModeModal.querySelector('.learn-flashcard').onclick = () => {
            learnModeModal.querySelector('.learn-modal-content').classList.toggle('flipped');
            if (learnModeModal.querySelector('.learn-modal-content').classList.contains('flipped')) {
                document.getElementById('learn-feedback-btns').style.display = 'flex';
            } else {
                document.getElementById('learn-feedback-btns').style.display = 'none';
            }
        };
    }

    async function recordAndProceed(wasCorrect) {
        const cardId = learnSession.flashcards[learnSession.currentIndex].id;
        if (wasCorrect) learnSession.correct++;
        else learnSession.incorrect++;

        await fetch('{{ url_for("record_learn_attempt") }}', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ flashcard_id: cardId, was_correct: wasCorrect })
        });

        learnSession.currentIndex++;
        displayCurrentLearnCard();
    }

    document.getElementById('learn-right-btn').addEventListener('click', () => recordAndProceed(true));
    document.getElementById('learn-wrong-btn').addEventListener('click', () => recordAndProceed(false));

    // --- Flashcard Creation Logic ---
    const aiGeneratorForm = document.getElementById('ai-generator-form');
    const aiLoadingSpinner = document.getElementById('ai-loading-spinner');

    aiGeneratorForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        aiLoadingSpinner.style.display = 'block';

        const topic = document.getElementById('ai-topic').value;
        const notes = document.getElementById('ai-notes').value;
        const text = notes || topic; // Use notes if provided, otherwise fall back to topic

        try {
            // 1. Generate flashcards from AI
            const genResponse = await fetch('{{ url_for("generate_flashcards_ai") }}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: text, topic: topic })
            });

            if (!genResponse.ok) throw new Error('AI generation failed.');
            
            const data = await genResponse.json();
            const generatedFlashcards = data.flashcards.map(fc => ({ ...fc, topic: topic }));

            // 2. Save the generated flashcards to the DB
            const saveResult = await saveFlashcards(generatedFlashcards, currentFolderId);
            if (saveResult) {
                // 3. Add them to the page and local state
                generatedFlashcards.forEach(fc => {
                    addFlashcardToDOM(fc);
                    if (currentFolderId === null) {
                        fullData.root_flashcards.push(fc);
                    } else {
                        findFolder(currentFolderId).flashcards.push(fc);
                    }
                });
                aiGeneratorForm.reset();
                createFlashcardModal.style.display = 'none';
            }
        } catch (error) {
            console.error('AI Generation Error:', error);
            alert('Failed to generate flashcards with AI. Please try again.');
        } finally {
            aiLoadingSpinner.style.display = 'none';
        }
    });

    async function saveFlashcards(flashcards, folderId) {
        try {
            const response = await fetch('{{ url_for("save_flashcards") }}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ flashcards: flashcards, folder_id: folderId })
            });
            if (!response.ok) throw new Error('Failed to save flashcards.');
            const result = await response.json();
            // Reload to get new IDs for the created cards. A more advanced implementation
            // would get the new IDs from the response and update the local state.
            window.location.reload(); 
            return result;
        } catch (error) {
            console.error('Save Error:', error);
            alert('Could not save flashcards. Please try again.');
        }
    }

    function openEmojiPicker() {
        const emojiModal = document.getElementById('emoji-picker-modal');
        const emojiGrid = document.getElementById('emoji-grid');
        const EMOJI_CATEGORIES = {
            'School & Science': ['ðŸ“š', 'ðŸ§ª', 'ðŸ”¬', 'ðŸ§®', 'ðŸ“œ', 'ðŸ’¡', 'ðŸ§ ', 'âœï¸', 'ðŸ“ˆ', 'ðŸ§¬'],
            'General': ['ðŸ“', 'â­', 'ðŸŽ¯', 'ðŸ”¥', 'âœ…', 'âŒ', 'ðŸ“Œ', 'ðŸ“Ž', 'ðŸ’¬', 'â“', 'â—'],
            'Nature': ['ðŸŒ', 'ðŸŒ¿', 'ðŸŒ³', 'ðŸŒŠ', 'â˜€ï¸', 'ðŸŒ™', 'ðŸŒ¸', 'ðŸ', 'ðŸ„', 'ðŸš'],
            'Animals': ['ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ¨', 'ðŸ¯', 'ðŸ¦', 'ðŸ®'],
            'Food': ['ðŸŽ', 'ðŸŒ', 'ðŸ‡', 'ðŸ“', 'ðŸ”', 'ðŸ•', 'ðŸŸ', 'ðŸ©', 'ðŸª', 'ðŸ¦']
        };
        
        emojiGrid.innerHTML = '';
        for (const category in EMOJI_CATEGORIES) {
            const categoryHeader = document.createElement('div');
            categoryHeader.className = 'emoji-category-header';
            categoryHeader.textContent = category;
            emojiGrid.appendChild(categoryHeader);

            EMOJI_CATEGORIES[category].forEach(emoji => {
                const emojiBtn = document.createElement('button');
                emojiBtn.className = 'emoji-btn';
                emojiBtn.textContent = emoji;
                emojiBtn.onclick = () => selectEmoji(emoji);
                emojiGrid.appendChild(emojiBtn);
            });
        }

        emojiModal.style.display = 'flex';
        emojiModal.onclick = (e) => {
            if (e.target === emojiModal) emojiModal.style.display = 'none';
        };
    }

    function selectEmoji(emoji) {
        if (itemToChangeIcon) {
            updateItemIcon(itemToChangeIcon.id, emoji);
        }
        document.getElementById('emoji-picker-modal').style.display = 'none';
    }

    async function updateItemIcon(itemId, newIcon) {
        try {
            const response = await fetch('{{ url_for("update_item") }}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ item_id: itemId, item_type: 'folder', icon: newIcon })
            });
            if (!response.ok) throw new Error('Failed to update icon.');
            window.location.reload();
        } catch (error) {
            console.error(error);
            alert('Error updating icon.');
        }
    }

    // --- Tab Switching in Creator Modal ---
    const creatorTabs = document.querySelector('.creator-tabs');
    creatorTabs.addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-link')) {
            const tabId = e.target.dataset.tab;

            // Update active tab button
            creatorTabs.querySelectorAll('.tab-link').forEach(tab => tab.classList.remove('active'));
            e.target.classList.add('active');

            // Show correct tab content
            document.querySelectorAll('#create-flashcard-modal .tab-content').forEach(content => {
                content.style.display = content.id === tabId ? 'block' : 'none';
            });
        }
    });

    // --- Manual Flashcard Creation ---
    const manualCreatorForm = document.getElementById('manual-creator-form');
    manualCreatorForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const question = document.getElementById('manual-question').value;
        const answer = document.getElementById('manual-answer').value;

        let topic = "General"; // Default topic if in root
        if (currentFolderId) {
            const parentFolder = findFolder(currentFolderId);
            if (parentFolder) {
                topic = parentFolder.name;
            }
        }

        const newFlashcard = { topic: topic, question, answer };

        const saveResult = await saveFlashcards([newFlashcard], currentFolderId);
        if (saveResult) {
            // Add to DOM and local state
            addFlashcardToDOM(newFlashcard);
            if (currentFolderId === null) {
                fullData.root_flashcards.push(newFlashcard);
            } else {
                findFolder(currentFolderId).flashcards.push(newFlashcard);
            }
            manualCreatorForm.reset();
            createFlashcardModal.style.display = 'none';
        }
    });


    // Global click listener to close menus
    document.addEventListener('click', function (e) {
        // If the click is not on a menu button and not inside a dropdown
        if (!e.target.closest('.item-menu-btn') && !e.target.closest('.item-menu-dropdown')) {
            // Close all open menus
            document.querySelectorAll('.item-card.menu-open').forEach(card => {
                card.classList.remove('menu-open');
                card.querySelector('.item-menu-dropdown').classList.remove('visible');
            });
        }
    });

    // --- INITIALIZATION ---
    function initialize() {
        folderTreeEl.innerHTML = '';
        renderFolderTree(fullData.folders, folderTreeEl);
        navigateToFolder(null); // Start at the root
    }

    initialize();
});
</script>
{% endblock %}