{% extends 'base.html' %}

{% block title %}Flashcards System{% endblock %}
{% block head %}<link rel="stylesheet" href="{{ url_for('static', filename='flashcards.css') }}">{% endblock %}

{% block content %}
<div class="flashcards-layout">
    <!-- Sidebar for Folders -->
    <aside class="flashcards-sidebar">
        <div class="sidebar-header">
            <h3>My Collection</h3>
            <button class="btn btn-ghost btn-sm" id="new-folder-btn">+ New Folder</button>
        </div>
        <div id="folder-tree">
            <!-- Folder structure will be rendered here by JavaScript -->
        </div>
    </aside>

    <!-- Main Content Area -->
    <main class="flashcards-main">
        <div class="flashcards-main-header">
            <h1 id="current-folder-name">All Flashcards</h1>
            <div class="actions">
                <button class="btn btn-secondary" id="new-flashcard-btn">Create Flashcard</button>
                <button class="btn btn-primary" id="learn-mode-btn">Learn</button>
            </div>
        </div>

        <!-- Breadcrumbs -->
        <nav id="breadcrumbs" aria-label="breadcrumb"></nav>

        <!-- Items (Folders and Flashcards) -->
        <div id="items-container" class="items-grid">
            <!-- Items will be rendered here by JavaScript -->
        </div>
    </main>
</div>

<!-- Learn Mode Modal -->
<div id="learn-mode-modal" class="modal-overlay" style="display: none;">
    <div class="learn-modal-content">
        <button class="modal-close-btn" id="close-learn-modal">&times;</button>
        <div class="learn-flashcard">
            <div class="learn-flashcard-inner">
                <div class="learn-flashcard-front">
                    <p id="learn-question"></p>
                </div>
                <div class="learn-flashcard-back">
                    <p id="learn-answer"></p>
                </div>
            </div>
        </div>
        <div class="learn-controls">
            <button id="prev-flashcard-btn" class="btn btn-secondary">Previous</button>
            <div id="learn-progress">1 / 10</div>
            <button id="next-flashcard-btn" class="btn btn-primary">Next</button>
        </div>
    </div>
</div>

<!-- Move Item Modal (Structure Only) -->
<div id="move-item-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h3>Move Item to...</h3>
        <div id="move-folder-tree">
            <!-- Simplified folder tree for selection -->
        </div>
        <div class="modal-actions">
            <button class="btn btn-secondary" id="cancel-move-btn">Cancel</button>
            <button class="btn btn-primary" id="confirm-move-btn">Move</button>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- STATE ---
    const fullData = {
        folders: {{ folder_structure | tojson | safe }},
        root_flashcards: {{ root_flashcards | tojson | safe }}
    };
    let itemToMove = null;
    let itemToChangeIcon = null;
    let currentFolderId = null;
    let breadcrumbs = [];

    // --- DOM ELEMENTS ---
    const folderTreeEl = document.getElementById('folder-tree');
    const itemsContainerEl = document.getElementById('items-container');
    const currentFolderNameEl = document.getElementById('current-folder-name');
    const breadcrumbsEl = document.getElementById('breadcrumbs');
    const newFolderBtn = document.getElementById('new-folder-btn');
    const moveItemModal = document.getElementById('move-item-modal');
    const moveFolderTreeEl = document.getElementById('move-folder-tree');
    const confirmMoveBtn = document.getElementById('confirm-move-btn');
    const cancelMoveBtn = document.getElementById('cancel-move-btn');

    // --- RENDER FUNCTIONS ---

    function renderFolderTree(folders, parentElement, level = 0) {
        const ul = document.createElement('ul');
        ul.style.paddingLeft = level > 0 ? '20px' : '0';
        ul.style.listStyle = 'none';

        folders.forEach(folder => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.id = `folder-link-${folder.id}`;
            a.href = '#';
            a.dataset.folderId = folder.id;
            a.innerHTML = `<span class="folder-icon">${folder.icon}</span> ${folder.name}`;
            a.addEventListener('click', (e) => {
                e.preventDefault();
                navigateToFolder(folder.id);
            });
            li.appendChild(a);

            if (folder.subfolders && folder.subfolders.length > 0) {
                renderFolderTree(folder.subfolders, li, level + 1);
            }
            ul.appendChild(li);
        });
        parentElement.appendChild(ul);
    }
    
    function renderMoveFolderTree(folders, parentElement, level = 0) {
        const ul = document.createElement('ul');
        ul.style.paddingLeft = level > 0 ? '20px' : '0';
        ul.style.listStyle = 'none';

        folders.forEach(folder => {
            // Don't allow moving a folder into itself or its children
            if (itemToMove && itemToMove.type === 'folder' && itemToMove.id === folder.id) {
                return;
            }

            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.folderId = folder.id;
            a.innerHTML = `<span class="folder-icon">${folder.icon}</span> ${folder.name}`;
            a.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#move-folder-tree a').forEach(link => link.classList.remove('active'));
                a.classList.add('active');
            });
            li.appendChild(a);
            ul.appendChild(li);
        });
        parentElement.appendChild(ul);
    }

    function renderItems(items) {
        itemsContainerEl.innerHTML = ''; // Clear current items
        
        // Render subfolders
        (items.folders || []).forEach(folder => {
            const folderEl = document.createElement('div');
            folderEl.className = 'item-card folder-item';
            folderEl.dataset.itemId = folder.id;
            folderEl.dataset.itemType = 'folder';
            folderEl.innerHTML = `
                <div class="item-icon">${folder.icon}</div>
                <div class="item-name">${folder.name}</div>
                <div class="item-menu-btn">...</div>
                <div class="item-menu-dropdown">
                    <a href="#" class="rename-btn">Rename</a>
                    <a href="#" class="change-icon-btn">Change Icon</a>
                    <a href="#" class="move-btn">Move</a>
                    <a href="#" class="delete-btn">Delete</a>
                </div>
            `;
            folderEl.addEventListener('click', (e) => {
                // Only navigate if the click was not on the menu button or inside the dropdown
                if (!e.target.closest('.item-menu-btn') && !e.target.closest('.item-menu-dropdown')) {
                    navigateToFolder(folder.id);
                }
            });
            itemsContainerEl.appendChild(folderEl);
        });

        // Render flashcards
        (items.flashcards || []).forEach(flashcard => {
            const flashcardEl = document.createElement('div');
            flashcardEl.className = 'item-card flashcard-item';
            flashcardEl.dataset.itemId = flashcard.id;
            flashcardEl.dataset.itemType = 'flashcard';
            flashcardEl.innerHTML = `
                <div class="item-content">
                    <div class="item-name">${flashcard.question}</div>
                    <div class="flashcard-item-topic">${flashcard.topic}</div>
                </div>
                <div class="item-menu-btn">...</div>
                <div class="item-menu-dropdown">
                    <a href="#" class="rename-btn">Rename</a>
                    <a href="#" class="move-btn">Move</a>
                    <a href="#" class="delete-btn">Delete</a>
                </div>
            `;
            // Could add a click handler to open a detail view
            itemsContainerEl.appendChild(flashcardEl);
        });
    }

    function renderBreadcrumbs() {
        breadcrumbsEl.innerHTML = '';
        const homeLink = document.createElement('a');
        homeLink.href = '#';
        homeLink.innerText = 'All Flashcards';
        homeLink.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToFolder(null);
        });
        breadcrumbsEl.appendChild(homeLink);

        breadcrumbs.forEach((crumb, index) => {
            breadcrumbsEl.innerHTML += ' / ';
            const crumbLink = document.createElement('a');
            crumbLink.href = '#';
            crumbLink.innerText = crumb.name;
            if (index < breadcrumbs.length - 1) {
                crumbLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    navigateToFolder(crumb.id);
                });
            }
            breadcrumbsEl.appendChild(crumbLink);
        });
    }

    // --- DATA & NAVIGATION LOGIC ---

    function findFolder(folderId, folders = fullData.folders) {
        for (const folder of folders) {
            if (folder.id === folderId) return folder;
            const found = findFolder(folderId, folder.subfolders);
            if (found) return found;
        }
        return null;
    }

    function buildBreadcrumbs(folderId, folders = fullData.folders, path = []) {
        for (const folder of folders) {
            const currentPath = [...path, { id: folder.id, name: folder.name }];
            if (folder.id === folderId) {
                return currentPath;
            }
            const foundPath = buildBreadcrumbs(folderId, folder.subfolders, currentPath);
            if (foundPath) return foundPath;
        }
        return null;
    }

    function navigateToFolder(folderId) {
        currentFolderId = folderId;
        if (folderId === null) {
            // Root view
            currentFolderNameEl.innerText = 'All Flashcards';
            breadcrumbs = [];
            renderItems({ folders: fullData.folders, flashcards: fullData.root_flashcards });
        } else {
            const folder = findFolder(folderId);
            if (folder) {
                currentFolderNameEl.innerText = folder.name;
                breadcrumbs = buildBreadcrumbs(folderId);
                renderItems({ folders: folder.subfolders, flashcards: folder.flashcards });
            }
        }
        renderBreadcrumbs();

        // Update active class in sidebar
        document.querySelectorAll('#folder-tree a').forEach(a => a.classList.remove('active'));
        if (folderId) {
            const activeLink = document.getElementById(`folder-link-${folderId}`);
            if (activeLink) activeLink.classList.add('active');
        }
    }

    // --- EVENT HANDLERS ---

    newFolderBtn.addEventListener('click', async () => {
        const name = prompt('Enter new folder name:');
        if (name && name.trim()) {
            try {
                const response = await fetch('{{ url_for("create_folder") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name.trim(), parent_id: currentFolderId })
                });
                if (!response.ok) throw new Error('Failed to create folder.');
                
                const newFolder = await response.json();
                
                // Add to local data structure and re-render
                const newFolderData = { ...newFolder, subfolders: [], flashcards: [] };
                if (currentFolderId === null) {
                    fullData.folders.push(newFolderData);
                } else {
                    const parent = findFolder(currentFolderId);
                    parent.subfolders.push(newFolderData);
                }
                
                // Re-render everything
                folderTreeEl.innerHTML = '';
                renderFolderTree(fullData.folders, folderTreeEl);
                navigateToFolder(currentFolderId);

            } catch (error) {
                console.error(error);
                alert('Error creating folder.');
            }
        }
    });

    // Event delegation for item menus
    itemsContainerEl.addEventListener('click', function(e) {
        const target = e.target;

        // Prevent card navigation when clicking menu button
        if (target.classList.contains('item-menu-btn')) {
            e.stopPropagation();
            // Close other menus
            document.querySelectorAll('.item-menu-dropdown.visible').forEach(menu => {
                if (menu !== target.nextElementSibling) {
                    menu.classList.remove('visible');
                }
            });
            target.nextElementSibling.classList.toggle('visible');
        }

        // Handle rename action
        if (target.classList.contains('rename-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            const itemId = card.dataset.itemId;
            const itemType = card.dataset.itemType;
            const currentName = card.querySelector('.item-name').innerText;
            const newName = prompt(`Enter new name for "${currentName}":`, currentName);

            if (newName && newName.trim() !== currentName) {
                fetch('{{ url_for("update_item") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_id: itemId, item_type: itemType, name: newName.trim() })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        // For simplicity, we reload the page to see changes.
                        // A more advanced implementation would update the state locally.
                        window.location.reload();
                    }
                });
            }
        }

        // Handle move action
        if (target.classList.contains('move-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            itemToMove = {
                id: card.dataset.itemId,
                type: card.dataset.itemType
            };
            openMoveModal();
        }

        // Handle change icon action
        if (target.classList.contains('change-icon-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            const itemId = card.dataset.itemId;
            const newIcon = prompt(`Enter a single emoji icon:`);

            // A simple validation to check if it's likely an emoji
            if (newIcon && newIcon.trim().length > 0 && /\p{Emoji}/u.test(newIcon.trim())) {
                updateItemIcon(itemId, newIcon.trim());
            } else if (newIcon) {
                alert("Please enter a valid emoji.");
            }
        }

        // Handle delete action
        if (target.classList.contains('delete-btn')) {
            e.stopPropagation();
            e.preventDefault();
            const card = target.closest('.item-card');
            const itemId = card.dataset.itemId;
            const itemType = card.dataset.itemType;
            const itemName = card.querySelector('.item-name').innerText;

            if (confirm(`Are you sure you want to delete "${itemName}"?`)) {
                fetch('{{ url_for("delete_item") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_id: itemId, item_type: itemType })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        card.remove(); // Remove from DOM instantly
                    } else {
                        alert(data.error || 'Failed to delete item.');
                    }
                });
            }
        }
    });

    // --- MODAL LOGIC ---

    function openMoveModal() {
        moveFolderTreeEl.innerHTML = '';
        // Add a "Root" option
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.dataset.folderId = 'null'; // Use string 'null' for root
        rootLink.innerHTML = `ðŸ  All Flashcards (Root)`;
        rootLink.addEventListener('click', (e) => {
            e.preventDefault();
            document.querySelectorAll('#move-folder-tree a').forEach(link => link.classList.remove('active'));
            rootLink.classList.add('active');
        });
        moveFolderTreeEl.appendChild(rootLink);

        renderMoveFolderTree(fullData.folders, moveFolderTreeEl);
        moveItemModal.style.display = 'flex';
    }

    confirmMoveBtn.addEventListener('click', async () => {
        const selectedLink = moveFolderTreeEl.querySelector('a.active');
        if (!selectedLink || !itemToMove) return;

        const targetFolderId = selectedLink.dataset.folderId === 'null' ? null : parseInt(selectedLink.dataset.folderId);

        try {
            const response = await fetch('{{ url_for("move_item") }}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ item_id: itemToMove.id, item_type: itemToMove.type, target_folder_id: targetFolderId })
            });
            if (!response.ok) throw new Error('Failed to move item.');
            
            window.location.reload(); // Reload to see changes
        } catch (error) {
            console.error(error);
            alert('Error moving item.');
        }
    });

    cancelMoveBtn.addEventListener('click', () => moveItemModal.style.display = 'none');
    moveItemModal.addEventListener('click', (e) => {
        if (e.target === moveItemModal) {
            moveItemModal.style.display = 'none';
        }
    });

    async function updateItemIcon(itemId, newIcon) {
        try {
            const response = await fetch('{{ url_for("update_item") }}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ item_id: itemId, item_type: 'folder', icon: newIcon })
            });
            if (!response.ok) throw new Error('Failed to update icon.');
            window.location.reload();
        } catch (error) {
            console.error(error);
            alert('Error updating icon.');
        }
    }

    // --- INITIALIZATION ---
    function initialize() {
        folderTreeEl.innerHTML = '';
        renderFolderTree(fullData.folders, folderTreeEl);
        navigateToFolder(null); // Start at the root
    }

    initialize();
});
</script>
{% endblock %}